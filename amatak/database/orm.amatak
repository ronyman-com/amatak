//Amatak ORM - Object Relational Mapper
//Provides high-level database abstraction

import SQLiteDriver from amatak.database.drivers.sqlite
import PostgresDriver from amatak.database.drivers.postgres
import SQLiteDriver from amatak.database.drivers.sqlite
import PostgresDriver from amatak.database.drivers.postgres
from amatak.security.middleware import security_middleware
from amatak.error_handling import error_handler

class Field:
    """Base field type for model definitions"""
    def __init__(self, field_type: str, primary_key=False, null=False, unique=False, default=None):
        self.field_type = field_type
        self.primary_key = primary_key
        self.null = null
        self.unique = unique
        self.default = default

class IntegerField(Field):
    """Integer field type"""
    def __init__(self, primary_key=False, null=False, unique=False, default=None):
        super().__init__("INTEGER", primary_key, null, unique, default)

class StringField(Field):
    """String field type"""
    def __init__(self, max_length=255, null=False, unique=False, default=None):
        super().__init__(f"VARCHAR({max_length})", False, null, unique, default)

class BooleanField(Field):
    """Boolean field type"""
    def __init__(self, null=False, default=None):
        super().__init__("BOOLEAN", False, null, False, default)

class FloatField(Field):
    """Floating point field type"""
    def __init__(self, null=False, unique=False, default=None):
        super().__init__("REAL", False, null, unique, default)

class DateTimeField(Field):
    """DateTime field type"""
    def __init__(self, null=False, auto_now=False, auto_now_add=False, default=None):
        if auto_now or auto_now_add:
            default = "CURRENT_TIMESTAMP"
        super().__init__("TIMESTAMP", False, null, False, default)
        self.auto_now = auto_now
        self.auto_now_add = auto_now_add

class ForeignKey(Field):
    """Foreign key relationship"""
    def __init__(self, model: str, null=False, on_delete="CASCADE"):
        super().__init__("INTEGER", False, null, False, None)
        self.model = model
        self.on_delete = on_delete

class Model:
    """Base model class for database objects"""
    
    _db = nil
    _table_name = ""
    _fields = {}
    _initialized = false
    
    def __init__(self, **kwargs):
        if not self._initialized:
            self._initialize_model()
        
        # Set field values from kwargs
        for field_name, field in self._fields.items():
            value = kwargs.get(field_name, field.default)
            setattr(self, field_name, value)
    
    @classmethod
    def _initialize_model(cls):
        """Initialize model metadata"""
        if cls._initialized:
            return
            
        cls._table_name = cls.__name__.lower()
        cls._fields = {}
        
        # Collect fields from class attributes
        for name, value in cls.__dict__.items():
            if isinstance(value, Field):
                cls._fields[name] = value
                if value.primary_key:
                    cls._pk_field = name
        
        cls._initialized = true

        @security_middleware.secure_operation
        def save(self):
            """Secured save operation"""
            return error_handler.wrap_operation(self._save_impl)
            
        def _save_impl(self):
            """Actual save implementation"""
            # ... existing save logic ...
            
        @classmethod
        @security_middleware.secure_operation
        def raw_query(cls, query, params=None):
            """Secured raw query execution"""
            return error_handler.wrap_operation(
                cls._raw_query_impl,
                query,
                params
            )
    
    @classmethod
    def connect(cls, db_driver):
        """Set database connection for model"""
        cls._db = db_driver
    
    @classmethod
    def create_table(cls):
        """Create table for this model"""
        if not cls._db:
            raise "Database connection not established"
        
        fields_sql = []
        for name, field in cls._fields.items():
            field_sql = f"{name} {field.field_type}"
            
            if field.primary_key:
                field_sql += " PRIMARY KEY"
                if field.field_type == "INTEGER":
                    field_sql += " AUTOINCREMENT" if isinstance(cls._db, SQLiteDriver) else " SERIAL"
            
            if not field.null:
                field_sql += " NOT NULL"
            
            if field.unique:
                field_sql += " UNIQUE"
            
            if field.default is not None:
                field_sql += f" DEFAULT {field.default}"
            
            fields_sql.append(field_sql)
        
        # Handle foreign key constraints
        fk_constraints = []
        for name, field in cls._fields.items():
            if isinstance(field, ForeignKey):
                fk_constraints.append(
                    f"FOREIGN KEY ({name}) REFERENCES {field.model}(id) ON DELETE {field.on_delete}"
                )
        
        sql = f"""
        CREATE TABLE IF NOT EXISTS {cls._table_name} (
            {', '.join(fields_sql + fk_constraints)}
        )
        """
        cls._db.execute(sql)
    
    def save(self):
        """Save object to database"""
        if not self._db:
            raise "Database connection not established"
        
        field_names = []
        placeholders = []
        values = []
        
        for name, field in self._fields.items():
            value = getattr(self, name, None)
            
            # Handle auto_now for DateTimeField
            if isinstance(field, DateTimeField) and field.auto_now:
                value = "CURRENT_TIMESTAMP"
            
            field_names.append(name)
            placeholders.append("?")
            values.append(value)
        
        if hasattr(self, 'id') and self.id is not None:
            # Update existing record
            set_clause = ", ".join([f"{name} = ?" for name in field_names])
            sql = f"""
            UPDATE {self._table_name}
            SET {set_clause}
            WHERE id = ?
            """
            self._db.execute(sql, values + [self.id])
        else:
            # Insert new record
            sql = f"""
            INSERT INTO {self._table_name} ({", ".join(field_names)})
            VALUES ({", ".join(placeholders)})
            """
            self._db.execute(sql, values)
            
            # Get generated ID
            if isinstance(self._db, SQLiteDriver):
                self.id = self._db.last_insert_id()
            else:
                result = self._db.execute("SELECT lastval()")
                self.id = result[0][0]
    
    @classmethod
    def get(cls, id):
        """Get object by primary key"""
        if not cls._db:
            raise "Database connection not established"
        
        result = cls._db.execute(
            f"SELECT * FROM {cls._table_name} WHERE id = ?",
            [id]
        )
        
        if not result:
            return nil
        
        return cls._create_from_row(result[0])
    
    @classmethod
    def filter(cls, **kwargs):
        """Filter objects by field values"""
        if not cls._db:
            raise "Database connection not established"
        
        conditions = []
        values = []
        
        for field, value in kwargs.items():
            if field not in cls._fields:
                raise f"Invalid field: {field}"
            
            conditions.append(f"{field} = ?")
            values.append(value)
        
        where_clause = " AND ".join(conditions) if conditions else "1=1"
        sql = f"SELECT * FROM {cls._table_name} WHERE {where_clause}"
        
        results = cls._db.execute(sql, values)
        return [cls._create_from_row(row) for row in results]
    
    @classmethod
    def all(cls):
        """Get all objects"""
        return cls.filter()
    
    def delete(self):
        """Delete object from database"""
        if not hasattr(self, 'id') or self.id is None:
            return
            
        self._db.execute(
            f"DELETE FROM {self._table_name} WHERE id = ?",
            [self.id]
        )
        self.id = None
    
    @classmethod
    def _create_from_row(cls, row):
        """Create model instance from database row"""
        kwargs = dict(row)
        return cls(**kwargs)
    
    @classmethod
    def raw_query(cls, query, params=None):
        """Execute raw SQL query"""
        if not cls._db:
            raise "Database connection not established"
        
        return cls._db.execute(query, params or [])

// Example model definition
class User(Model):
    id = IntegerField(primary_key=True)
    username = StringField(unique=True)
    email = StringField(unique=True)
    is_active = BooleanField(default=True)
    created_at = DateTimeField(auto_now_add=True)
    last_login = DateTimeField(null=True)

class Post(Model):
    id = IntegerField(primary_key=True)
    title = StringField(max_length=200)
    content = StringField(max_length=5000)
    author = ForeignKey("user")
    created_at = DateTimeField(auto_now_add=True)
    updated_at = DateTimeField(auto_now=True)

// Export important classes
export Model, Field, IntegerField, StringField, BooleanField, FloatField, DateTimeField, ForeignKey








    
    